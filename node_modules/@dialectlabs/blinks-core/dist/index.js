// src/utils/caip-2.ts
var BlockchainIds = {
  SOLANA_MAINNET: "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
  SOLANA_DEVNET: "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
  SOLANA_TESTNET: "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3",
  ETHEREUM_MAINNET: "eip155:1"
};
var BlockchainNames = {
  [BlockchainIds.SOLANA_MAINNET]: "Solana Mainnet",
  [BlockchainIds.SOLANA_DEVNET]: "Solana Devnet",
  [BlockchainIds.SOLANA_TESTNET]: "Solana Testnet",
  [BlockchainIds.ETHEREUM_MAINNET]: "Ethereum Mainnet"
};
function getShortBlockchainName(id) {
  const blockchainName = BlockchainNames[id];
  if (!blockchainName) {
    const [chainId, reference] = id.split(":");
    if (chainId && reference) {
      const truncatedReference = reference.length > 3 ? reference.slice(0, 3) + "..." : reference;
      return `${chainId}:${truncatedReference}`;
    } else {
      return id.length > 8 ? id.slice(0, 8) + "..." : id;
    }
  }
  return blockchainName;
}

// src/utils/constants.ts
var SOLANA_ACTION_PREFIX = /^(solana-action:|solana:)/;

// src/utils/interstitial-url.ts
function isInterstitial(url) {
  try {
    const urlObj = new URL(url);
    const actionUrl = urlObj.searchParams.get("action");
    if (!actionUrl) {
      return { isInterstitial: false };
    }
    const urlDecodedActionUrl = decodeURIComponent(actionUrl);
    if (!SOLANA_ACTION_PREFIX.test(urlDecodedActionUrl)) {
      return { isInterstitial: false };
    }
    const decodedActionUrl = urlDecodedActionUrl.replace(
      SOLANA_ACTION_PREFIX,
      ""
    );
    const decodedActionUrlObj = new URL(decodedActionUrl);
    return {
      isInterstitial: true,
      decodedActionUrl: decodedActionUrlObj.toString()
    };
  } catch (e) {
    console.error(
      `[@dialectlabs/blinks] Failed to check if URL is interstitial: ${url}`,
      e
    );
    return { isInterstitial: false };
  }
}

// src/utils/proxify.ts
var proxyUrl = "https://proxy.dial.to";
function setProxyUrl(url) {
  if (!url) {
    console.warn(
      "[@dialectlabs/blinks] Proxy URL is not set, proxy will be disabled"
    );
    proxyUrl = null;
    return;
  }
  try {
    new URL(url);
  } catch (e) {
    console.warn("[@dialectlabs/blinks] Invalid proxy URL", e);
    return;
  }
  proxyUrl = url;
}
function proxify(url) {
  const baseUrl = new URL(url);
  if (shouldIgnoreProxy(baseUrl)) {
    return baseUrl;
  }
  const proxifiedUrl = new URL(proxyUrl);
  proxifiedUrl.searchParams.set("url", url);
  return proxifiedUrl;
}
function proxifyImage(url) {
  const baseUrl = new URL(url);
  if (shouldIgnoreProxy(baseUrl)) {
    return baseUrl;
  }
  const proxifiedUrl = new URL(`${proxyUrl}/image`);
  proxifiedUrl.searchParams.set("url", url);
  return proxifiedUrl;
}
function shouldIgnoreProxy(url) {
  if (url.hostname === "localhost" || url.hostname === "127.0.0.1") {
    return true;
  }
  if (!proxyUrl) {
    return true;
  }
  return false;
}

// src/utils/security.ts
var checkSecurity = (state, securityLevel) => {
  switch (securityLevel) {
    case "only-trusted":
      return state === "trusted";
    case "non-malicious":
      return state !== "malicious";
    case "all":
      return true;
  }
};
var isUrlSameOrigin = (origin, url) => {
  if (!url.startsWith("http")) {
    return true;
  }
  const urlObj = new URL(url);
  return urlObj.origin === origin;
};

// src/utils/url-mapper.ts
var ActionsURLMapper = class {
  config;
  constructor(config) {
    this.config = config;
  }
  mapUrl(url) {
    const urlObj = typeof url === "string" ? new URL(url) : url;
    const queryParams = urlObj.search;
    for (const action of this.config.rules) {
      if (this.isExactMatch(action.pathPattern, urlObj)) {
        return `${action.apiPath}${queryParams}`;
      }
      const match = this.matchPattern(action.pathPattern, urlObj);
      if (match) {
        return this.constructMappedUrl(
          action.apiPath,
          match,
          queryParams,
          urlObj.origin
        );
      }
    }
    return null;
  }
  // Helper method to check for exact match
  isExactMatch(pattern, urlObj) {
    return pattern === `${urlObj.origin}${urlObj.pathname}`;
  }
  // Helper method to match the URL with the pattern
  matchPattern(pattern, urlObj) {
    const fullPattern = new RegExp(
      `^${pattern.replace(/\*\*/g, "(.*)").replace(/\/(\*)/g, "/([^/]+)")}$`
    );
    const urlToMatch = pattern.startsWith("http") ? urlObj.toString() : urlObj.pathname;
    return urlToMatch.match(fullPattern);
  }
  // Helper method to construct the mapped URL
  constructMappedUrl(apiPath, match, queryParams, origin) {
    let mappedPath = apiPath;
    match.slice(1).forEach((group) => {
      mappedPath = mappedPath.replace(/\*+/, group);
    });
    if (apiPath.startsWith("http")) {
      const mappedUrl = new URL(mappedPath);
      return `${mappedUrl.origin}${mappedUrl.pathname}${queryParams}`;
    }
    return `${origin}${mappedPath}${queryParams}`;
  }
};
async function unfurlUrlToActionApiUrl(actionUrl) {
  const url = new URL(actionUrl);
  const strUrl = actionUrl.toString();
  if (SOLANA_ACTION_PREFIX.test(strUrl)) {
    return strUrl.replace(SOLANA_ACTION_PREFIX, "");
  }
  const interstitialData = isInterstitial(url);
  if (interstitialData.isInterstitial) {
    return interstitialData.decodedActionUrl;
  }
  const actionsJsonUrl = url.origin + "/actions.json";
  const actionsJson = await fetch(proxify(actionsJsonUrl)).then(
    (res) => res.json()
  );
  const actionsUrlMapper = new ActionsURLMapper(actionsJson);
  return actionsUrlMapper.mapUrl(url);
}

// src/api/Action/Action.ts
import { nanoid } from "nanoid/non-secure";

// package.json
var package_default = {
  name: "@dialectlabs/blinks-core",
  version: "0.12.0",
  license: "Apache-2.0",
  private: false,
  sideEffects: true,
  type: "module",
  repository: {
    type: "git",
    url: "https://github.com/dialectlabs/blinks"
  },
  scripts: {
    build: "tsup-node",
    dev: "tsup-node --watch"
  },
  main: "dist/index.cjs",
  module: "dist/index.js",
  types: "dist/index.d.ts",
  exports: {
    ".": {
      import: "./dist/index.js",
      require: "./dist/index.cjs",
      types: "./dist/index.d.ts"
    }
  },
  files: [
    "dist"
  ],
  devDependencies: {
    "@solana/actions-spec": "~2.3.0",
    "@types/react": "^18.3.3",
    "@types/react-dom": "^18.3.0",
    "@typescript-eslint/eslint-plugin": "^7.16.1",
    "@typescript-eslint/parser": "^7.16.1",
    autoprefixer: "^10.4.19",
    eslint: "^8.57.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-react": "^7.34.4",
    "eslint-plugin-react-hooks": "^4.6.2",
    postcss: "^8.4.39",
    "postcss-prefix-selector": "^1.16.1",
    prettier: "^3.3.3",
    "prettier-plugin-organize-imports": "^4.0.0",
    "prettier-plugin-tailwindcss": "^0.6.5",
    tailwindcss: "^3.4.3",
    tsup: "^8.2.0",
    typescript: "^5.5.3"
  },
  peerDependencies: {
    react: ">=18"
  },
  dependencies: {
    "@solana/web3.js": "^1.95.1",
    nanoid: "^5.0.7"
  }
};

// src/utils/dependency-versions.ts
var pkg = package_default;
var ACTIONS_SPEC_VERSION = pkg.devDependencies["@solana/actions-spec"].replace(/[^\d.]/g, "");

// src/api/Action/action-supportability.ts
var MAX_SUPPORTED_ACTION_VERSION = ACTIONS_SPEC_VERSION;
var DEFAULT_SUPPORTED_BLOCKCHAIN_IDS = [
  BlockchainIds.SOLANA_MAINNET,
  BlockchainIds.SOLANA_DEVNET
];
var BASELINE_ACTION_VERSION = "2.2";
var BASELINE_ACTION_BLOCKCHAIN_IDS = [BlockchainIds.SOLANA_MAINNET];
var defaultActionSupportStrategy = async (action) => {
  const { version: actionVersion, blockchainIds: actionBlockchainIds } = action.metadata;
  if (!actionVersion || !actionBlockchainIds || actionBlockchainIds.length === 0) {
    return {
      isSupported: false,
      message: "Action compatibility metadata is not set. Please contact the action provider."
    };
  }
  const supportedActionVersion = MAX_SUPPORTED_ACTION_VERSION;
  const supportedBlockchainIds = !action.adapterUnsafe ? actionBlockchainIds : action.adapterUnsafe.metadata.supportedBlockchainIds;
  const versionSupported = isVersionSupported({
    actionVersion,
    supportedActionVersion
  });
  const blockchainSupported = isBlockchainSupported({
    actionBlockchainIds,
    supportedBlockchainIds
  });
  const notSupportedBlockchainIds = actionBlockchainIds.filter(
    (id) => !supportedBlockchainIds.includes(id)
  );
  const notSupportedActionBlockchainNames = notSupportedBlockchainIds.map(
    getShortBlockchainName
  );
  if (!versionSupported && !blockchainSupported) {
    const blockchainMessage = notSupportedActionBlockchainNames.length === 1 ? `blockchain ${notSupportedActionBlockchainNames[0]}` : `blockchains ${notSupportedActionBlockchainNames.join(", ")}`;
    return {
      isSupported: false,
      message: `Action version ${actionVersion} and ${blockchainMessage} are not supported by your Blink client.`
    };
  }
  if (!versionSupported) {
    return {
      isSupported: false,
      message: `Action version ${actionVersion} is not supported by your Blink client.`
    };
  }
  if (!blockchainSupported) {
    const blockchainMessage = notSupportedActionBlockchainNames.length === 1 ? `Action blockchain ${notSupportedActionBlockchainNames[0]} is not supported by your Blink client.` : `Action blockchains ${notSupportedActionBlockchainNames.join(", ")} are not supported by your Blink client.`;
    return {
      isSupported: false,
      message: blockchainMessage
    };
  }
  return {
    isSupported: true
  };
};
function isVersionSupported({
  supportedActionVersion,
  actionVersion
}) {
  return compareSemverIgnoringPatch(actionVersion, supportedActionVersion) <= 0;
}
function compareSemverIgnoringPatch(v1, v2) {
  const [major1, minor1] = v1.split(".").map(Number);
  const [major2, minor2] = v2.split(".").map(Number);
  if (major1 !== major2) {
    return major1 - major2;
  } else if (minor1 !== minor2) {
    return minor1 - minor2;
  }
  return 0;
}
function isBlockchainSupported({
  supportedBlockchainIds,
  actionBlockchainIds
}) {
  if (actionBlockchainIds.length === 0 || supportedBlockchainIds.length === 0) {
    return false;
  }
  const sanitizedSupportedBlockchainIds = supportedBlockchainIds.map(
    (it) => it.trim()
  );
  const sanitizedActionBlockchainIds = actionBlockchainIds.map(
    (it) => it.trim()
  );
  return sanitizedActionBlockchainIds.every(
    (chain) => sanitizedSupportedBlockchainIds.includes(chain)
  );
}

// src/api/Action/Action.ts
var MULTI_VALUE_TYPES = ["checkbox"];
var EXPERIMENTAL_LIVE_DATA_DEFAULT_DELAY_MS = 1e3;
var Action = class _Action {
  constructor(_url, _data, _metadata, _supportStrategy, _adapter, _chainMetadata = { isChained: false }, _id, _experimental) {
    this._url = _url;
    this._data = _data;
    this._metadata = _metadata;
    this._supportStrategy = _supportStrategy;
    this._adapter = _adapter;
    this._chainMetadata = _chainMetadata;
    this._id = _id;
    this._experimental = _experimental;
    if (_data.type === "completed" || !_data.links?.actions) {
      this._actions = [
        new ButtonActionComponent(this, _data.label, _url, "transaction")
      ];
      return;
    }
    const urlObj = new URL(_url);
    this._actions = _data.links.actions.map((action) => {
      const href = action.href.startsWith("http") ? action.href : urlObj.origin + action.href;
      return componentFactory(
        this,
        action.label,
        href,
        action.type ?? "transaction",
        action.parameters
      );
    });
  }
  _actions;
  // this API MAY change in the future
  get liveData_experimental() {
    const liveData = this._experimental?.liveData;
    if (!liveData) {
      return null;
    }
    return {
      enabled: liveData.enabled,
      delayMs: liveData.delayMs ? Math.max(liveData.delayMs, EXPERIMENTAL_LIVE_DATA_DEFAULT_DELAY_MS) : EXPERIMENTAL_LIVE_DATA_DEFAULT_DELAY_MS
    };
  }
  get id() {
    return this._id;
  }
  get isChained() {
    return this._chainMetadata.isChained;
  }
  get isInline() {
    return this._chainMetadata.isChained ? this._chainMetadata.isInline : false;
  }
  get type() {
    return this._data.type;
  }
  get url() {
    return this._url;
  }
  get icon() {
    if (this._data.icon.startsWith("data:")) {
      return this._data.icon;
    }
    return proxifyImage(this._data.icon).toString();
  }
  get title() {
    return this._data.title;
  }
  get description() {
    return this._data.description;
  }
  get disabled() {
    return this._data.disabled ?? false;
  }
  get actions() {
    return this._actions;
  }
  get error() {
    return this._data.error?.message ?? null;
  }
  get metadata() {
    return {
      blockchainIds: this._metadata.blockchainIds ?? BASELINE_ACTION_BLOCKCHAIN_IDS,
      version: this._metadata.version ?? BASELINE_ACTION_VERSION
    };
  }
  get adapterUnsafe() {
    return this._adapter;
  }
  get adapter() {
    if (!this._adapter) {
      throw new Error("No adapter provided");
    }
    return this._adapter;
  }
  setAdapter(adapter) {
    this._adapter = adapter;
  }
  async isSupported() {
    try {
      return await this._supportStrategy(this);
    } catch (e) {
      console.error(
        `[@dialectlabs/blinks] Failed to check supportability for action ${this.url}`
      );
      return {
        isSupported: false,
        message: "Failed to check supportability, please contact your Blink client provider."
      };
    }
  }
  async chain(next, chainData) {
    const id = nanoid();
    if (next.type === "inline") {
      return new _Action(
        this.url,
        next.action,
        this.metadata,
        this._supportStrategy,
        this.adapter,
        {
          isChained: true,
          isInline: true
        },
        id
      );
    }
    const baseUrlObj = new URL(this.url);
    if (!isUrlSameOrigin(baseUrlObj.origin, next.href)) {
      console.error(
        `Chained action is not the same origin as the current action. Original: ${this.url}, chained: ${next.href}`
      );
      return null;
    }
    const href = next.href.startsWith("http") ? next.href : baseUrlObj.origin + next.href;
    const proxyUrl2 = proxify(href);
    const response = await fetch(proxyUrl2, {
      method: "POST",
      body: JSON.stringify(chainData),
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json"
      }
    });
    if (!response.ok) {
      console.error(
        `Failed to fetch chained action ${proxyUrl2}, action url: ${next.href}`
      );
      return null;
    }
    const data = await response.json();
    const metadata = getActionMetadata(response);
    return new _Action(
      href,
      data,
      metadata,
      this._supportStrategy,
      this.adapter,
      {
        isChained: true,
        isInline: false
      },
      id
    );
  }
  // be sure to use this only if the action is valid
  static hydrate(url, data, metadata, supportStrategy, adapter) {
    const id = nanoid();
    return new _Action(
      url,
      data,
      metadata,
      supportStrategy,
      adapter,
      { isChained: false },
      id
    );
  }
  static async _fetch(apiUrl, adapter, supportStrategy = defaultActionSupportStrategy, chainMetadata, id) {
    const proxyUrl2 = proxify(apiUrl);
    const response = await fetch(proxyUrl2, {
      headers: {
        Accept: "application/json"
      }
    });
    if (!response.ok) {
      throw new Error(
        `Failed to fetch action ${proxyUrl2}, action url: ${apiUrl}`
      );
    }
    const data = await response.json();
    const metadata = getActionMetadata(response);
    return new _Action(
      apiUrl,
      { ...data, type: "action" },
      metadata,
      supportStrategy,
      adapter,
      chainMetadata,
      id,
      data.dialectExperimental
    );
  }
  static async fetch(apiUrl, adapter, supportStrategy = defaultActionSupportStrategy) {
    const id = nanoid();
    return _Action._fetch(
      apiUrl,
      adapter,
      supportStrategy,
      {
        isChained: false
      },
      id
    );
  }
  refresh() {
    return _Action._fetch(
      this.url,
      this.adapter,
      this._supportStrategy,
      this._chainMetadata,
      this._id
    );
  }
};
var getActionMetadata = (response) => {
  const blockchainIds = response.headers.get("x-blockchain-ids")?.split(",").map((id) => id.trim());
  const version = response.headers.get("x-action-version")?.trim();
  return {
    blockchainIds,
    version
  };
};
var componentFactory = (parent, label, href, type, parameters) => {
  if (!parameters?.length) {
    return new ButtonActionComponent(parent, label, href, type);
  }
  if (parameters.length > 1) {
    return new FormActionComponent(parent, label, href, type, parameters);
  }
  const [parameter] = parameters;
  if (!parameter.type) {
    return new SingleValueActionComponent(
      parent,
      label,
      href,
      type,
      parameters
    );
  }
  if (MULTI_VALUE_TYPES.includes(parameter.type)) {
    return new MultiValueActionComponent(parent, label, href, type, parameters);
  }
  return new SingleValueActionComponent(parent, label, href, type, parameters);
};

// src/api/Action/action-components/AbstractActionComponent.ts
var AbstractActionComponent = class {
  constructor(_parent, _label, _href, _type, _parameters) {
    this._parent = _parent;
    this._label = _label;
    this._href = _href;
    this._type = _type;
    this._parameters = _parameters;
  }
  get parent() {
    return this._parent;
  }
  get label() {
    return this._label;
  }
  get parameters() {
    return this._parameters ?? [];
  }
  get type() {
    return this._type;
  }
  async post(account) {
    const proxyUrl2 = proxify(this.href);
    const response = await fetch(proxyUrl2, {
      method: "POST",
      body: JSON.stringify(this.buildBody(account)),
      headers: {
        "Content-Type": "application/json"
      }
    });
    if (!response.ok) {
      const error = await response.json();
      console.error(
        `[@dialectlabs/blinks] Failed to execute action ${proxyUrl2}, href ${this.href}, reason: ${error.message}`
      );
      throw {
        message: error.message
      };
    }
    return await response.json();
  }
};

// src/api/Action/action-components/ButtonActionComponent.ts
var ButtonActionComponent = class extends AbstractActionComponent {
  constructor(_parent, _label, _href, _type, _parameters, _parentComponent) {
    super(_parent, _label, _href, _type, _parameters);
    this._parent = _parent;
    this._label = _label;
    this._href = _href;
    this._type = _type;
    this._parameters = _parameters;
    this._parentComponent = _parentComponent;
  }
  get parentComponent() {
    return this._parentComponent ?? null;
  }
  buildBody(account) {
    return { account };
  }
  get href() {
    return this._href;
  }
};

// src/api/Action/action-components/SingleValueActionComponent.ts
var SingleValueActionComponent = class extends AbstractActionComponent {
  constructor(_parent, _label, _href, _type, _parameters, _parentComponent) {
    super(_parent, _label, _href, _type, _parameters);
    this._parent = _parent;
    this._label = _label;
    this._href = _href;
    this._type = _type;
    this._parameters = _parameters;
    this._parentComponent = _parentComponent;
  }
  parameterValue = null;
  get parentComponent() {
    return this._parentComponent ?? null;
  }
  buildBody(account) {
    if (this._href.indexOf(`{${this.parameter.name}}`) > -1 || this.parameterValue === null) {
      return { account };
    }
    return {
      account,
      data: {
        [this.parameter.name]: this.parameterValue
      }
    };
  }
  get parameter() {
    const [param] = this.parameters;
    return param;
  }
  setValue(value) {
    this.parameterValue = value;
  }
  get href() {
    return this._href.replace(
      `{${this.parameter.name}}`,
      encodeURIComponent(this.parameterValue?.toString().trim() ?? "")
    );
  }
  toButtonActionComponent() {
    return new ButtonActionComponent(
      this._parent,
      this._label,
      this._href,
      this._type,
      void 0,
      this
    );
  }
};

// src/api/Action/action-components/FormActionComponent.ts
var FormActionComponent = class extends AbstractActionComponent {
  constructor(_parent, _label, _href, _type, _parameters, _parentComponent) {
    super(_parent, _label, _href, _type, _parameters);
    this._parent = _parent;
    this._label = _label;
    this._href = _href;
    this._type = _type;
    this._parameters = _parameters;
    this._parentComponent = _parentComponent;
  }
  parameterValues = {};
  get parentComponent() {
    return this._parentComponent ?? null;
  }
  // any, since we don't know the parameter names on the client level
  buildBody(account) {
    const paramNames = Object.keys(this.parameterValues);
    const bodyParams = [];
    paramNames.forEach((paramName) => {
      if (this._href.indexOf(`{${paramName}}`) === -1) {
        bodyParams.push(paramName);
      }
    });
    if (bodyParams.length > 0) {
      return {
        account,
        data: Object.fromEntries(
          paramNames.filter((name) => bodyParams.includes(name)).map((paramName) => [paramName, this.parameterValues[paramName]])
        )
      };
    }
    return { account };
  }
  get href() {
    const replacedHref = this.parameters.reduce((href, param) => {
      const value = this.parameterValues[param.name];
      if (!value) {
        return href;
      }
      return href.replace(
        `{${param.name}}`,
        encodeURIComponent(
          typeof value === "string" ? value : value?.join(",")
        )
      );
    }, this._href);
    return replacedHref.replaceAll(/={[^}]+}&/g, "=&").replaceAll(/={[^}]+}/g, "=");
  }
  setValue(value, name) {
    this.parameterValues[name] = value;
  }
  toButtonActionComponent() {
    return new ButtonActionComponent(
      this._parent,
      this._label,
      this.href,
      this._type,
      void 0,
      this
    );
  }
  toInputActionComponent(paramName) {
    const parameter = this.parameters.find((param) => param.name === paramName);
    if (!parameter) {
      throw new Error(`Input Parameter ${paramName} not found`);
    }
    return new SingleValueActionComponent(
      this._parent,
      this._label,
      this._href,
      this._type,
      [parameter],
      this
    );
  }
};

// src/api/Action/action-components/MultiValueActionComponent.ts
var MultiValueActionComponent = class extends AbstractActionComponent {
  constructor(_parent, _label, _href, _type, _parameters, _parentComponent) {
    super(_parent, _label, _href, _type, _parameters);
    this._parent = _parent;
    this._label = _label;
    this._href = _href;
    this._type = _type;
    this._parameters = _parameters;
    this._parentComponent = _parentComponent;
  }
  parameterValue = [];
  get parentComponent() {
    return this._parentComponent ?? null;
  }
  // any, since we don't know the parameter names on the client level
  buildBody(account) {
    if (this._href.indexOf(`{${this.parameter.name}}`) > -1) {
      return { account };
    }
    return {
      account,
      data: {
        [this.parameter.name]: this.isMultiOptions ? this.parameterValue : this.parameterValue[0]
      }
    };
  }
  get isMultiOptions() {
    return this.parameter.type === "checkbox";
  }
  get parameter() {
    const [param] = this.parameters;
    return param;
  }
  setValue(value) {
    this.parameterValue = typeof value === "string" ? [value] : value;
  }
  get href() {
    return this._href.replace(
      `{${this.parameter.name}}`,
      encodeURIComponent(this.parameterValue.join(","))
    );
  }
  toButtonActionComponent() {
    return new ButtonActionComponent(
      this._parent,
      this._label,
      this._href,
      this._type,
      void 0,
      this
    );
  }
};

// src/api/Action/action-components/guards.ts
var isPatternAllowed = (parameter) => {
  return parameter.type !== "select" && parameter.type !== "radio" && parameter.type !== "checkbox";
};
var isParameterSelectable = (parameter) => {
  return parameter.type === "select" || parameter.type === "radio" || parameter.type === "checkbox";
};

// src/api/ActionConfig.ts
import { Connection } from "@solana/web3.js";
var ActionConfig = class _ActionConfig {
  constructor(rpcUrlOrConnection, adapter) {
    this.adapter = adapter;
    if (!rpcUrlOrConnection) {
      throw new Error("rpcUrl or connection is required");
    }
    this.connection = typeof rpcUrlOrConnection === "string" ? new Connection(rpcUrlOrConnection, "confirmed") : rpcUrlOrConnection;
  }
  static CONFIRM_TIMEOUT_MS = 6e4 * 1.2;
  // 20% extra time
  static DEFAULT_METADATA = {
    supportedBlockchainIds: DEFAULT_SUPPORTED_BLOCKCHAIN_IDS
  };
  connection;
  get metadata() {
    return this.adapter.metadata ?? _ActionConfig.DEFAULT_METADATA;
  }
  signTransaction(tx, context) {
    return this.adapter.signTransaction(tx, context);
  }
  confirmTransaction(signature) {
    return new Promise((res, rej) => {
      const start = Date.now();
      const confirm = async () => {
        if (Date.now() - start >= _ActionConfig.CONFIRM_TIMEOUT_MS) {
          rej(new Error("Unable to confirm transaction: timeout reached"));
          return;
        }
        try {
          const status = await this.connection.getSignatureStatus(signature);
          if (status.value?.err) {
            rej(
              new Error(
                `Transaction execution failed, check wallet for details`
              )
            );
            return;
          }
          if (status.value && status.value.confirmations !== null) {
            res();
            return;
          }
        } catch (e) {
          console.error(
            "[@dialectlabs/blinks] Error confirming transaction",
            e
          );
        }
        setTimeout(confirm, 3e3);
      };
      confirm();
    });
  }
  async connect(context) {
    try {
      return await this.adapter.connect(context);
    } catch {
      return null;
    }
  }
};

// src/api/ActionsRegistry.ts
var DEFAULT_REFRESH_INTERVAL = 10 * 60 * 1e3;
var ActionsRegistry = class _ActionsRegistry {
  static instance = null;
  actionsByHost;
  websitesByHost;
  interstitialsByHost;
  initPromise = null;
  constructor(config) {
    this.actionsByHost = config ? Object.fromEntries(
      config.actions.map((action) => [action.host, action])
    ) : {};
    this.websitesByHost = config ? Object.fromEntries(
      config.websites.map((website) => [website.host, website])
    ) : {};
    this.interstitialsByHost = config ? Object.fromEntries(
      config.interstitials.map((interstitial) => [
        interstitial.host,
        interstitial
      ])
    ) : {};
  }
  static getInstance(config) {
    if (this.instance === null || config) {
      this.instance = new _ActionsRegistry(config);
    }
    return this.instance;
  }
  async init() {
    if (this.initPromise !== null) {
      return;
    }
    await this.refresh();
    setInterval(() => this.refresh(), DEFAULT_REFRESH_INTERVAL);
  }
  async refresh() {
    this.initPromise = fetchActionsRegistryConfig();
    const config = await this.initPromise;
    this.actionsByHost = Object.fromEntries(
      config.actions.map((action) => [action.host, action])
    );
    this.websitesByHost = Object.fromEntries(
      config.websites.map((website) => [website.host, website])
    );
    this.interstitialsByHost = Object.fromEntries(
      config.interstitials.map((interstitial) => [
        interstitial.host,
        interstitial
      ])
    );
  }
  lookup(url, type = "action") {
    if (type === "action") {
      return this.lookupAction(url);
    }
    if (type === "website") {
      return this.lookupWebsite(url);
    }
    if (type === "interstitial") {
      return this.lookupInterstitial(url);
    }
    return null;
  }
  lookupAction(url) {
    try {
      const urlObj = new URL(url);
      const host = urlObj.host;
      return this.actionsByHost[host] ?? null;
    } catch (e) {
      console.error(
        `[@dialectlabs/blinks] Failed to lookup action for URL: ${url}`,
        e
      );
      return null;
    }
  }
  lookupWebsite(url) {
    try {
      const urlObj = new URL(url);
      const host = urlObj.host;
      return this.websitesByHost[host] ?? null;
    } catch (e) {
      console.error(
        `[@dialectlabs/blinks] Failed to lookup website for URL: ${url}`,
        e
      );
      return null;
    }
  }
  lookupInterstitial(url) {
    try {
      const urlObj = new URL(url);
      const host = urlObj.host;
      return this.interstitialsByHost[host] ?? null;
    } catch (e) {
      console.error(
        `[@dialectlabs/blinks] Failed to lookup interstitial for URL: ${url}`,
        e
      );
      return null;
    }
  }
};
var mergeActionStates = (...states) => {
  if (states.includes("malicious")) {
    return "malicious";
  }
  if (states.includes("unknown")) {
    return "unknown";
  }
  return "trusted";
};
var getExtendedActionState = (actionOrUrl) => {
  return ActionsRegistry.getInstance().lookup(
    typeof actionOrUrl === "string" ? actionOrUrl : actionOrUrl.url,
    "action"
  )?.state ?? "unknown";
};
var getExtendedWebsiteState = (url) => {
  return ActionsRegistry.getInstance().lookup(url, "website")?.state ?? "unknown";
};
var getExtendedInterstitialState = (url) => {
  return ActionsRegistry.getInstance().lookup(url, "interstitial")?.state ?? "unknown";
};
async function fetchActionsRegistryConfig() {
  try {
    const response = await fetch("https://actions-registry.dial.to/all");
    if (!response.ok) {
      console.error(
        "[@dialectlabs/blinks] Failed to fetch actions registry config",
        await response.json()
      );
      return { actions: [], interstitials: [], websites: [] };
    }
    return await response.json();
  } catch (e) {
    console.error(
      "[@dialectlabs/blinks] Failed to fetch actions registry config",
      e
    );
    return { actions: [], interstitials: [], websites: [] };
  }
}

// src/BlinkContainer.tsx
import {
  useEffect,
  useMemo,
  useReducer,
  useState
} from "react";

// src/utils/type-guards.ts
var isSignTransactionError = (data) => !!data.error;
var isPostRequestError = (data) => !!data.error;

// src/utils/validators.ts
var isURL = (url) => {
  try {
    new URL(url);
    return true;
  } catch {
    return false;
  }
};

// src/BlinkContainer.tsx
import { jsx } from "react/jsx-runtime";
var DisclaimerType = /* @__PURE__ */ ((DisclaimerType2) => {
  DisclaimerType2["BLOCKED"] = "blocked";
  DisclaimerType2["UNKNOWN"] = "unknown";
  return DisclaimerType2;
})(DisclaimerType || {});
var ExecutionType = /* @__PURE__ */ ((ExecutionType2) => {
  ExecutionType2["CHECK_SUPPORTABILITY"] = "CHECK_SUPPORTABILITY";
  ExecutionType2["INITIATE"] = "INITIATE";
  ExecutionType2["FINISH"] = "FINISH";
  ExecutionType2["FAIL"] = "FAIL";
  ExecutionType2["RESET"] = "RESET";
  ExecutionType2["SOFT_RESET"] = "SOFT_RESET";
  ExecutionType2["UNBLOCK"] = "UNBLOCK";
  ExecutionType2["BLOCK"] = "BLOCK";
  return ExecutionType2;
})(ExecutionType || {});
var executionReducer = (state, action) => {
  switch (action.type) {
    case "CHECK_SUPPORTABILITY" /* CHECK_SUPPORTABILITY */:
      return {
        status: "checking-supportability",
        checkingSupportability: true
      };
    case "INITIATE" /* INITIATE */:
      return { status: "executing", executingAction: action.executingAction };
    case "FINISH" /* FINISH */:
      return {
        ...state,
        status: "success",
        successMessage: action.successMessage,
        errorMessage: null
      };
    case "FAIL" /* FAIL */:
      return {
        ...state,
        status: "error",
        errorMessage: action.errorMessage,
        successMessage: null
      };
    case "RESET" /* RESET */:
      return {
        status: "idle"
      };
    case "SOFT_RESET" /* SOFT_RESET */:
      return {
        ...state,
        executingAction: null,
        status: "idle",
        errorMessage: action.errorMessage,
        successMessage: null
      };
    case "BLOCK" /* BLOCK */:
      return {
        status: "blocked"
      };
    case "UNBLOCK" /* UNBLOCK */:
      return {
        status: "idle"
      };
  }
};
var getOverallActionState = (action, websiteUrl) => {
  const actionState = getExtendedActionState(action);
  const originalUrlData = websiteUrl ? isInterstitial(websiteUrl) : null;
  if (!originalUrlData) {
    return {
      action: actionState
    };
  }
  if (originalUrlData.isInterstitial) {
    return {
      action: actionState,
      origin: getExtendedInterstitialState(websiteUrl),
      originType: "interstitials"
    };
  }
  return {
    action: actionState,
    origin: getExtendedWebsiteState(websiteUrl),
    originType: "websites"
  };
};
var checkSecurityFromActionState = (state, normalizedSecurityLevel) => {
  const checkAction = checkSecurity(
    state.action,
    normalizedSecurityLevel.actions
  );
  if (!state.origin) {
    return checkAction;
  }
  return checkAction && checkSecurity(state.origin, normalizedSecurityLevel[state.originType]);
};
var DEFAULT_SECURITY_LEVEL = "only-trusted";
var BlinkContainer = ({
  action: initialAction,
  websiteUrl,
  websiteText,
  callbacks,
  securityLevel = DEFAULT_SECURITY_LEVEL,
  Layout,
  selector
}) => {
  const [action, setAction] = useState(initialAction);
  const singleComponent = useMemo(() => selector?.(action), [action, selector]);
  const isPartialAction = typeof selector === "function";
  const normalizedSecurityLevel = useMemo(() => {
    if (typeof securityLevel === "string") {
      return {
        websites: securityLevel,
        interstitials: securityLevel,
        actions: securityLevel
      };
    }
    return securityLevel;
  }, [securityLevel]);
  const [actionState, setActionState] = useState(
    getOverallActionState(action, websiteUrl)
  );
  const [supportability, setSupportability] = useState({
    isSupported: true
  });
  const overallState = useMemo(
    () => mergeActionStates(
      ...[actionState.action, actionState.origin].filter(
        Boolean
      )
    ),
    [actionState]
  );
  const isPassingSecurityCheck = isPartialAction ? true : checkSecurityFromActionState(actionState, normalizedSecurityLevel);
  const [executionState, dispatch] = useReducer(executionReducer, {
    status: isPartialAction ? "idle" : "checking-supportability"
  });
  useEffect(() => {
    if (action === initialAction || action.isChained) {
      return;
    }
    setAction(initialAction);
    setActionState(getOverallActionState(initialAction, websiteUrl));
    dispatch({
      type: isPartialAction ? "RESET" /* RESET */ : "CHECK_SUPPORTABILITY" /* CHECK_SUPPORTABILITY */
    });
  }, [initialAction, websiteUrl]);
  useEffect(() => {
    callbacks?.onActionMount?.(
      action,
      websiteUrl ?? action.url,
      actionState.action
    );
  }, [action.id]);
  useEffect(() => {
    const liveDataConfig = action.liveData_experimental;
    if (!liveDataConfig || !liveDataConfig.enabled || executionState.status !== "idle" || action.isChained) {
      return;
    }
    let timeout;
    const fetcher = async () => {
      try {
        const newAction = await action.refresh();
        if (executionState.status === "idle") {
          setAction(newAction);
        }
      } catch (e) {
        console.error(
          `[@dialectlabs/blinks] Failed to fetch live data for action ${action.url}`
        );
        timeout = setTimeout(fetcher, liveDataConfig.delayMs);
      }
    };
    timeout = setTimeout(fetcher, liveDataConfig.delayMs);
    return () => {
      clearTimeout(timeout);
    };
  }, [action, executionState.status, isPartialAction]);
  useEffect(() => {
    const checkSupportability = async (action2) => {
      if (action2.isChained || executionState.status !== "checking-supportability") {
        return;
      }
      try {
        const supportability2 = await action2.isSupported();
        setSupportability(supportability2);
      } finally {
        dispatch({
          type: overallState !== "malicious" && isPassingSecurityCheck ? "RESET" /* RESET */ : "BLOCK" /* BLOCK */
        });
      }
    };
    checkSupportability(action);
  }, [action, executionState.status, overallState, isPassingSecurityCheck]);
  const execute = async (component, params) => {
    if (params) {
      if (component instanceof FormActionComponent) {
        Object.entries(params).forEach(
          ([name, value]) => component.setValue(value, name)
        );
      }
      if (component instanceof MultiValueActionComponent) {
        component.setValue(params[component.parameter.name]);
      }
      if (component instanceof SingleValueActionComponent) {
        const incomingValues = params[component.parameter.name];
        const value = typeof incomingValues === "string" ? incomingValues : incomingValues[0];
        component.setValue(value);
      }
    }
    const newActionState = getOverallActionState(action, websiteUrl);
    const newIsPassingSecurityCheck = checkSecurityFromActionState(
      newActionState,
      normalizedSecurityLevel
    );
    if ((newActionState.action !== actionState.action || newActionState.origin !== actionState.origin) && !newIsPassingSecurityCheck) {
      setActionState(newActionState);
      dispatch({ type: "BLOCK" /* BLOCK */ });
      return;
    }
    dispatch({ type: "INITIATE" /* INITIATE */, executingAction: component });
    const context = {
      action: component.parent,
      actionType: actionState.action,
      originalUrl: websiteUrl ?? component.parent.url,
      triggeredLinkedAction: component
    };
    try {
      const account = await action.adapter.connect(context);
      if (!account) {
        dispatch({ type: "RESET" /* RESET */ });
        return;
      }
      const response = await component.post(account).catch((e) => ({ error: e.message }));
      if (isPostRequestError(response)) {
        dispatch({
          type: "SOFT_RESET" /* SOFT_RESET */,
          errorMessage: isPostRequestError(response) ? response.error : "Transaction data missing"
        });
        return;
      }
      const chain = async (signature) => {
        if (!response.links?.next) {
          dispatch({
            type: "FINISH" /* FINISH */,
            successMessage: response.message
          });
          return;
        }
        const nextAction = await action.chain(response.links.next, {
          signature,
          account
        });
        if (!nextAction || isPartialAction && !selector?.(nextAction)) {
          dispatch({
            type: "FINISH" /* FINISH */,
            successMessage: response.message
          });
          return;
        }
        setAction(nextAction);
        dispatch({ type: "RESET" /* RESET */ });
      };
      if (response.type === "transaction" || !response.type) {
        const signResult = await action.adapter.signTransaction(
          response.transaction,
          context
        );
        if (!signResult || isSignTransactionError(signResult)) {
          dispatch({ type: "RESET" /* RESET */ });
          return;
        }
        await action.adapter.confirmTransaction(signResult.signature, context);
        await chain(signResult.signature);
        return;
      }
      if (response.type === "post") {
        await chain();
        return;
      }
      if (response.type === "external-link") {
        if (isURL(response.externalLink)) {
          return {
            type: "external-link",
            data: {
              externalLink: response.externalLink
            },
            onNext: () => chain(),
            onCancel: () => chain()
          };
        }
        await chain();
        return;
      }
    } catch (e) {
      dispatch({
        type: "SOFT_RESET" /* SOFT_RESET */,
        errorMessage: e.message ?? "Unknown error, please try again"
      });
    }
  };
  const disclaimer = useMemo(() => {
    if (overallState === "malicious") {
      return {
        type: "blocked" /* BLOCKED */,
        ignorable: isPassingSecurityCheck,
        hidden: executionState.status !== "blocked" && executionState.status !== "checking-supportability",
        onSkip: () => dispatch({ type: "UNBLOCK" /* UNBLOCK */ })
      };
    }
    if (overallState === "unknown") {
      return {
        type: "unknown" /* UNKNOWN */,
        ignorable: isPassingSecurityCheck
      };
    }
    return null;
  }, [executionState.status, isPassingSecurityCheck, overallState]);
  const blinkCaption = useMemo(() => {
    if (executionState.errorMessage) {
      return { type: "error", text: executionState.errorMessage };
    }
    if (executionState.successMessage) {
      return { type: "success", text: executionState.successMessage };
    }
    return null;
  }, [executionState.errorMessage, executionState.successMessage]);
  return /* @__PURE__ */ jsx(
    Layout,
    {
      securityState: overallState,
      websiteUrl,
      websiteText,
      action,
      component: singleComponent,
      caption: blinkCaption,
      executionStatus: executionState.status,
      executingAction: executionState.executingAction,
      executeFn: execute,
      disclaimer,
      supportability,
      id: action.id
    }
  );
};

// src/hooks/useAction.ts
import { useEffect as useEffect3, useState as useState3 } from "react";

// src/hooks/useActionRegistryInterval.ts
import { useEffect as useEffect2, useState as useState2 } from "react";
function useActionsRegistryInterval() {
  const [isRegistryLoaded, setRegistryLoaded] = useState2(false);
  useEffect2(() => {
    ActionsRegistry.getInstance().init().then(() => {
      setRegistryLoaded(true);
    });
  }, [isRegistryLoaded]);
  return { isRegistryLoaded };
}

// src/hooks/useAction.ts
function useActionApiUrl(url) {
  const [apiUrl, setApiUrl] = useState3(null);
  useEffect3(() => {
    let ignore = false;
    unfurlUrlToActionApiUrl(new URL(url)).then((apiUrl2) => {
      if (ignore) {
        return;
      }
      setApiUrl(apiUrl2);
    }).catch((e) => {
      console.error(
        "[@dialectlabs/blinks-core] Failed to unfurl action URL",
        e
      );
      setApiUrl(null);
    });
    return () => {
      ignore = true;
    };
  }, [url]);
  return { actionApiUrl: apiUrl };
}
function useAction({
  url,
  adapter,
  supportStrategy = defaultActionSupportStrategy
}) {
  const { isRegistryLoaded } = useActionsRegistryInterval();
  const { actionApiUrl } = useActionApiUrl(url);
  const [action, setAction] = useState3(null);
  const [isLoading, setIsLoading] = useState3(false);
  useEffect3(() => {
    setIsLoading(true);
    if (!isRegistryLoaded || !actionApiUrl) {
      return;
    }
    let ignore = false;
    Action.fetch(actionApiUrl, void 0, supportStrategy).then((action2) => {
      if (ignore) {
        return;
      }
      setAction(action2);
    }).catch((e) => {
      console.error("[@dialectlabs/blinks-core] Failed to fetch action", e);
      setAction(null);
    }).finally(() => {
      if (!ignore) {
        setIsLoading(false);
      }
    });
    return () => {
      ignore = true;
    };
  }, [actionApiUrl, isRegistryLoaded, supportStrategy]);
  useEffect3(() => {
    action?.setAdapter(adapter);
  }, [action, adapter]);
  return { action, isLoading };
}
export {
  AbstractActionComponent,
  Action,
  ActionConfig,
  ActionsRegistry,
  ActionsURLMapper,
  BASELINE_ACTION_BLOCKCHAIN_IDS,
  BASELINE_ACTION_VERSION,
  BlinkContainer,
  BlockchainIds,
  ButtonActionComponent,
  DEFAULT_SUPPORTED_BLOCKCHAIN_IDS,
  DisclaimerType,
  ExecutionType,
  FormActionComponent,
  MAX_SUPPORTED_ACTION_VERSION,
  MultiValueActionComponent,
  SingleValueActionComponent,
  checkSecurity,
  defaultActionSupportStrategy,
  getExtendedActionState,
  getExtendedInterstitialState,
  getExtendedWebsiteState,
  isBlockchainSupported,
  isInterstitial,
  isParameterSelectable,
  isPatternAllowed,
  isVersionSupported,
  mergeActionStates,
  proxify,
  proxifyImage,
  setProxyUrl,
  unfurlUrlToActionApiUrl,
  useAction,
  useActionsRegistryInterval
};
