import { ActionGetResponse, NextActionLink, PostNextActionLink, NextActionPostRequest, NextAction, LinkedActionType, TypedActionParameter, ActionPostRequest, ActionPostResponse, GeneralParameterType, SelectableParameterType } from '@solana/actions-spec';
export * from '@solana/actions-spec';
export { Action as TypedAction } from '@solana/actions-spec';
import { Connection } from '@solana/web3.js';
import * as react_jsx_runtime from 'react/jsx-runtime';
import { ComponentType } from 'react';

interface DialectExperimentalFeatures {
    dialectExperimental?: {
        liveData?: {
            enabled: boolean;
            delayMs?: number;
        };
    };
}
type ExtendedActionGetResponse = ActionGetResponse & DialectExperimentalFeatures;

interface ActionContext {
    originalUrl: string;
    action: Action$1;
    actionType: 'trusted' | 'malicious' | 'unknown';
    triggeredLinkedAction: AbstractActionComponent;
}
interface IncomingActionConfig {
    rpcUrl: string;
    adapter: Pick<ActionAdapter, 'connect' | 'signTransaction'> & Partial<Pick<ActionAdapter, 'metadata'>>;
}
/**
 * Metadata for an action adapter.
 *
 * @property supportedBlockchainIds List of CAIP-2 blockchain IDs the adapter supports.
 *
 * @see {BlockchainIds}
 */
interface ActionAdapterMetadata {
    /**
     * List of CAIP-2 blockchain IDs the adapter supports.
     */
    supportedBlockchainIds: string[];
}
interface ActionAdapter {
    metadata: ActionAdapterMetadata;
    connect: (context: ActionContext) => Promise<string | null>;
    signTransaction: (tx: string, context: ActionContext) => Promise<{
        signature: string;
    } | {
        error: string;
    }>;
    confirmTransaction: (signature: string, context: ActionContext) => Promise<void>;
}
declare class ActionConfig implements ActionAdapter {
    private adapter;
    private static readonly CONFIRM_TIMEOUT_MS;
    private static readonly DEFAULT_METADATA;
    private connection;
    constructor(rpcUrlOrConnection: string | Connection, adapter: IncomingActionConfig['adapter']);
    get metadata(): ActionAdapterMetadata;
    signTransaction(tx: string, context: ActionContext): Promise<{
        signature: string;
    } | {
        error: string;
    }>;
    confirmTransaction(signature: string): Promise<void>;
    connect(context: ActionContext): Promise<string | null>;
}

/**
 * Max spec version the Blink client supports.
 */
declare const MAX_SUPPORTED_ACTION_VERSION: string;
declare const DEFAULT_SUPPORTED_BLOCKCHAIN_IDS: string[];
/**
 * Baseline action version to be used when not set by action provider.
 * Defaults to latest release that doesn't support versioning.
 */
declare const BASELINE_ACTION_VERSION = "2.2";
/**
 * Baseline blockchain IDs to be used when not set by action provider.
 * Defaults to Solana mainnet.
 */
declare const BASELINE_ACTION_BLOCKCHAIN_IDS: string[];
type IsVersionSupportedParams = {
    actionVersion: string;
    supportedActionVersion: string;
};
type IsBlockchainIdSupportedParams = {
    actionBlockchainIds: string[];
    supportedBlockchainIds: string[];
};
type ActionSupportability = {
    isSupported: true;
} | {
    isSupported: false;
    message: string;
};
type ActionSupportStrategy = (action: Action$1) => Promise<ActionSupportability>;
/**
 * Default implementation for checking if an action is supported.
 * Checks if the action version and the action blockchain IDs are supported by blink.
 * @param action Action.
 *
 * @see {isVersionSupported}
 * @see {isBlockchainSupported}
 */
declare const defaultActionSupportStrategy: ActionSupportStrategy;
/**
 * Check if the action version is supported by blink.
 * @param supportedActionVersion The version the blink supports.
 * @param actionVersion The version of the action.
 *
 * @returns `true` if the action version is less than or equal to the supported ignoring patch version, `false` otherwise.
 */
declare function isVersionSupported({ supportedActionVersion, actionVersion, }: IsVersionSupportedParams): boolean;
/**
 * Check if action blockchain IDs are supported by the blink.
 *
 * @param supportedBlockchainIds List of CAIP-2 blockchain IDs the client supports.
 * @param actionBlockchainIds List of CAIP-2 blockchain IDs the action supports.
 *
 * @returns `true` if all action blockchain IDs are supported by blink, `false` otherwise.
 *
 * @see BlockchainIds
 */
declare function isBlockchainSupported({ supportedBlockchainIds, actionBlockchainIds, }: IsBlockchainIdSupportedParams): boolean;

interface ActionMetadata {
    blockchainIds?: string[];
    version?: string;
}
interface LiveData {
    enabled: boolean;
    delayMs?: number;
}
declare class Action$1 {
    private readonly _url;
    private readonly _data;
    private readonly _metadata;
    private readonly _supportStrategy;
    private _adapter?;
    private readonly _chainMetadata;
    private readonly _id?;
    private readonly _experimental?;
    private readonly _actions;
    private constructor();
    get liveData_experimental(): Required<LiveData> | null;
    get id(): string | undefined;
    get isChained(): boolean;
    get isInline(): boolean;
    get type(): "action" | "completed";
    get url(): string;
    get icon(): string;
    get title(): string;
    get description(): string;
    get disabled(): boolean;
    get actions(): AbstractActionComponent[];
    get error(): string | null;
    get metadata(): ActionMetadata;
    get adapterUnsafe(): ActionAdapter | undefined;
    get adapter(): ActionAdapter;
    setAdapter(adapter: ActionAdapter): void;
    isSupported(): Promise<{
        isSupported: true;
    } | {
        isSupported: boolean;
        message: string;
    }>;
    chain<N extends NextActionLink>(next: N, chainData?: N extends PostNextActionLink ? NextActionPostRequest : never): Promise<Action$1 | null>;
    static hydrate(url: string, data: NextAction, metadata: ActionMetadata, supportStrategy: ActionSupportStrategy, adapter?: ActionAdapter): Action$1;
    private static _fetch;
    static fetch(apiUrl: string, adapter?: ActionAdapter, supportStrategy?: ActionSupportStrategy): Promise<Action$1>;
    refresh(): Promise<Action$1>;
}

declare abstract class AbstractActionComponent {
    protected _parent: Action$1;
    protected _label: string;
    protected _href: string;
    protected _type: LinkedActionType;
    protected _parameters?: TypedActionParameter[] | undefined;
    protected constructor(_parent: Action$1, _label: string, _href: string, _type: LinkedActionType, _parameters?: TypedActionParameter[] | undefined);
    get parent(): Action$1;
    get label(): string;
    get parameters(): TypedActionParameter[];
    get type(): LinkedActionType;
    abstract get href(): string;
    protected abstract buildBody(account: string): ActionPostRequest;
    post(account: string): Promise<ActionPostResponse>;
}

declare class ButtonActionComponent extends AbstractActionComponent {
    protected _parent: Action$1;
    protected _label: string;
    protected _href: string;
    protected _type: LinkedActionType;
    protected _parameters?: TypedActionParameter[] | undefined;
    protected _parentComponent?: AbstractActionComponent | undefined;
    constructor(_parent: Action$1, _label: string, _href: string, _type: LinkedActionType, _parameters?: TypedActionParameter[] | undefined, _parentComponent?: AbstractActionComponent | undefined);
    get parentComponent(): AbstractActionComponent | null;
    protected buildBody(account: string): ActionPostRequest;
    get href(): string;
}

declare class SingleValueActionComponent extends AbstractActionComponent {
    protected _parent: Action$1;
    protected _label: string;
    protected _href: string;
    protected _type: LinkedActionType;
    protected _parameters?: TypedActionParameter[] | undefined;
    protected _parentComponent?: AbstractActionComponent | undefined;
    private parameterValue;
    constructor(_parent: Action$1, _label: string, _href: string, _type: LinkedActionType, _parameters?: TypedActionParameter[] | undefined, _parentComponent?: AbstractActionComponent | undefined);
    get parentComponent(): AbstractActionComponent | null;
    protected buildBody(account: string): ActionPostRequest<any>;
    get parameter(): TypedActionParameter<GeneralParameterType>;
    setValue(value: string): void;
    get href(): string;
    toButtonActionComponent(): ButtonActionComponent;
}

declare class FormActionComponent extends AbstractActionComponent {
    protected _parent: Action$1;
    protected _label: string;
    protected _href: string;
    protected _type: LinkedActionType;
    protected _parameters?: TypedActionParameter[] | undefined;
    protected _parentComponent?: AbstractActionComponent | undefined;
    private parameterValues;
    constructor(_parent: Action$1, _label: string, _href: string, _type: LinkedActionType, _parameters?: TypedActionParameter[] | undefined, _parentComponent?: AbstractActionComponent | undefined);
    get parentComponent(): AbstractActionComponent | null;
    protected buildBody(account: string): ActionPostRequest<any>;
    get href(): string;
    setValue(value: string | Array<string>, name: string): void;
    toButtonActionComponent(): ButtonActionComponent;
    toInputActionComponent(paramName: string): SingleValueActionComponent;
}

declare class MultiValueActionComponent extends AbstractActionComponent {
    protected _parent: Action$1;
    protected _label: string;
    protected _href: string;
    protected _type: LinkedActionType;
    protected _parameters?: TypedActionParameter[] | undefined;
    protected _parentComponent?: AbstractActionComponent | undefined;
    private parameterValue;
    constructor(_parent: Action$1, _label: string, _href: string, _type: LinkedActionType, _parameters?: TypedActionParameter[] | undefined, _parentComponent?: AbstractActionComponent | undefined);
    get parentComponent(): AbstractActionComponent | null;
    protected buildBody(account: string): ActionPostRequest<any>;
    get isMultiOptions(): boolean;
    get parameter(): TypedActionParameter<SelectableParameterType>;
    setValue(value: string | Array<string>): void;
    get href(): string;
    toButtonActionComponent(): ButtonActionComponent;
}

declare const isPatternAllowed: (parameter: TypedActionParameter) => boolean;
declare const isParameterSelectable: (parameter: TypedActionParameter) => parameter is TypedActionParameter<SelectableParameterType>;

interface ActionCallbacksConfig {
    onActionMount: (action: Action$1, originalUrl: string, type: 'trusted' | 'malicious' | 'unknown') => void;
}

type LookupType = 'action' | 'website' | 'interstitial';
declare class ActionsRegistry {
    private static instance;
    private actionsByHost;
    private websitesByHost;
    private interstitialsByHost;
    private initPromise;
    private constructor();
    static getInstance(config?: ActionsRegistryConfig): ActionsRegistry;
    init(): Promise<void>;
    refresh(): Promise<void>;
    lookup(url: string | URL, type?: LookupType): RegisteredEntity | null;
    private lookupAction;
    private lookupWebsite;
    private lookupInterstitial;
}
interface ActionsRegistryConfig {
    actions: RegisteredEntity[];
    websites: RegisteredEntity[];
    interstitials: RegisteredEntity[];
}
interface RegisteredEntity {
    host: string;
    state: 'trusted' | 'malicious';
}
type SecurityActionState = RegisteredEntity['state'] | 'unknown';
declare const mergeActionStates: (...states: SecurityActionState[]) => SecurityActionState;
declare const getExtendedActionState: (actionOrUrl: Action$1 | string) => SecurityActionState;
declare const getExtendedWebsiteState: (url: string) => SecurityActionState;
declare const getExtendedInterstitialState: (url: string) => SecurityActionState;

interface SolanaPaySpecGetResponse {
    label: string;
    icon: string;
}
interface SolanaPaySpecPostRequestBody {
    account: string;
}
interface SolanaPaySpecPostResponse {
    transaction: string;
    message?: string;
    redirect?: string;
}

/**
 * CAIP-2 Blockchain IDs.
 */
declare const BlockchainIds: {
    SOLANA_MAINNET: string;
    SOLANA_DEVNET: string;
    SOLANA_TESTNET: string;
    ETHEREUM_MAINNET: string;
};

type IsInterstitialResult = {
    isInterstitial: true;
    decodedActionUrl: string;
} | {
    isInterstitial: false;
};
declare function isInterstitial(url: string | URL): IsInterstitialResult;

declare function setProxyUrl(url: string): void;
declare function proxify(url: string): URL;
declare function proxifyImage(url: string): URL;

type SecurityLevel = 'only-trusted' | 'non-malicious' | 'all';
declare const checkSecurity: (state: SecurityActionState, securityLevel: SecurityLevel) => boolean;

type Action = {
    pathPattern: string;
    apiPath: string;
};
type ActionsJsonConfig = {
    rules: Action[];
};
declare class ActionsURLMapper {
    private config;
    constructor(config: ActionsJsonConfig);
    mapUrl(url: string | URL): string | null;
    private isExactMatch;
    private matchPattern;
    private constructMappedUrl;
}
declare function unfurlUrlToActionApiUrl(actionUrl: URL | string): Promise<string | null>;

type BlinkSecurityState = SecurityActionState;
declare enum DisclaimerType {
    BLOCKED = "blocked",
    UNKNOWN = "unknown"
}
type Disclaimer = {
    type: DisclaimerType.BLOCKED;
    ignorable: boolean;
    hidden: boolean;
    onSkip: () => void;
} | {
    type: DisclaimerType.UNKNOWN;
    ignorable: boolean;
};
interface BlinkCaption {
    type: 'success' | 'error';
    text: string;
}
type ExtraExecutionData = {
    type: Extract<LinkedActionType, 'external-link'>;
    data: {
        externalLink: string;
    };
    onNext: () => void;
    onCancel?: () => void;
};
interface BaseBlinkLayoutProps {
    id?: string;
    securityState: BlinkSecurityState;
    action: Action$1;
    component?: AbstractActionComponent | null;
    websiteUrl?: string | null;
    websiteText?: string | null;
    disclaimer?: Disclaimer | null;
    caption?: BlinkCaption | null;
    executeFn: (component: AbstractActionComponent, params?: Record<string, string | string[]>) => Promise<ExtraExecutionData | void>;
    executionStatus: ExecutionStatus;
    executingAction?: AbstractActionComponent | null;
    supportability: ActionSupportability;
}
type ExecutionStatus = 'blocked' | 'checking-supportability' | 'idle' | 'executing' | 'success' | 'error';
interface ExecutionState {
    status: ExecutionStatus;
    checkingSupportability?: boolean;
    executingAction?: AbstractActionComponent | null;
    errorMessage?: string | null;
    successMessage?: string | null;
}
declare enum ExecutionType {
    CHECK_SUPPORTABILITY = "CHECK_SUPPORTABILITY",
    INITIATE = "INITIATE",
    FINISH = "FINISH",
    FAIL = "FAIL",
    RESET = "RESET",
    SOFT_RESET = "SOFT_RESET",
    UNBLOCK = "UNBLOCK",
    BLOCK = "BLOCK"
}
type Source = 'websites' | 'interstitials' | 'actions';
type NormalizedSecurityLevel = Record<Source, SecurityLevel>;
interface BlinkContainerProps {
    action: Action$1;
    selector?: (currentAction: Action$1) => AbstractActionComponent | null;
    websiteUrl?: string | null;
    websiteText?: string | null;
    callbacks?: Partial<ActionCallbacksConfig>;
    securityLevel?: SecurityLevel | NormalizedSecurityLevel;
    Layout: ComponentType<BaseBlinkLayoutProps>;
}
declare const BlinkContainer: ({ action: initialAction, websiteUrl, websiteText, callbacks, securityLevel, Layout, selector, }: BlinkContainerProps) => react_jsx_runtime.JSX.Element;

interface UseActionOptions {
    url: string | URL;
    adapter: ActionAdapter;
    securityRegistryRefreshInterval?: number;
    supportStrategy?: ActionSupportStrategy;
}
declare function useAction({ url, adapter, supportStrategy, }: UseActionOptions): {
    action: Action$1 | null;
    isLoading: boolean;
};

declare function useActionsRegistryInterval(): {
    isRegistryLoaded: boolean;
};

export { AbstractActionComponent, Action$1 as Action, type ActionAdapter, type ActionAdapterMetadata, type ActionCallbacksConfig, ActionConfig, type ActionContext, type ActionSupportStrategy, type ActionSupportability, type ActionsJsonConfig, ActionsRegistry, type ActionsRegistryConfig, ActionsURLMapper, BASELINE_ACTION_BLOCKCHAIN_IDS, BASELINE_ACTION_VERSION, type BaseBlinkLayoutProps, type BlinkCaption, BlinkContainer, type BlinkContainerProps, type BlinkSecurityState, BlockchainIds, ButtonActionComponent, DEFAULT_SUPPORTED_BLOCKCHAIN_IDS, type DialectExperimentalFeatures, type Disclaimer, DisclaimerType, type ExecutionState, type ExecutionStatus, ExecutionType, type ExtendedActionGetResponse, type ExtraExecutionData, FormActionComponent, type IncomingActionConfig, type IsInterstitialResult, type LookupType, MAX_SUPPORTED_ACTION_VERSION, MultiValueActionComponent, type RegisteredEntity, type SecurityActionState, type SecurityLevel, SingleValueActionComponent, type SolanaPaySpecGetResponse, type SolanaPaySpecPostRequestBody, type SolanaPaySpecPostResponse, checkSecurity, defaultActionSupportStrategy, getExtendedActionState, getExtendedInterstitialState, getExtendedWebsiteState, isBlockchainSupported, isInterstitial, isParameterSelectable, isPatternAllowed, isVersionSupported, mergeActionStates, proxify, proxifyImage, setProxyUrl, unfurlUrlToActionApiUrl, useAction, useActionsRegistryInterval };
